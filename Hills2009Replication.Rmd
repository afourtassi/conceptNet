---
title: "Replication of Hills 2009"
author: "Isaac Scheinfeld"
date: "`r Sys.Date()`"
output:
  html_document:
    theme: default
---
# Background

Questions

1. Are shared features sufficient to form meaningful categories?
2. Are some kinds of features more important than others?
3. Are perceptual or conceptual features more important for forming superordinate categories?
4. Are perceptual features a developmentally earlier source of categorical information?
5. Are conceptual features  privileged in superordinate category formation?

Hills intends to "take the feature correlation approach to build network representations, and then use the formalisms of graph theory to examine the noun–feature relationships in terms of the structure they provide." "By examining the small-world structure of early noun networks – as well as other graph- theoretic properties – we take a quantitative approach to evaluating the structural contributions of perceptual and conceptual features in the development of early categories." "What is needed [] is a better understanding of [perceptual and conceptual features'] inter-related roles in a larger system of developing categories."

Hills intends to address these specific questions:

1. Do features provide sufficient structure to infer common adult taxonomic categorizations among the nouns children know at 30 months of age?
2. If so, what are the available categories?
3. How robust are these categories to more or less stringent criteria for feature correlations?
4. Do perceptual and conceptual features differ in the structure they provide – are some feature types more robust, more discriminating, or more redundant?

# Methods

```{r echo=FALSE, message=FALSE, warning=FALSE} 
library(purrr) # fp library
library(readr) # read text data files (csv, etc.)
library(ggplot2) # plotting
library(langcog) # useful things used by Language and Cognition Lab
library(dplyr) # for working with datafram-like objects
library(tidyr) # for data tidying
library(wordbankr) # access to wordbank data
library(stringr) # common string operations
library(broom) # converts R function outputs to tidy data frames
library(igraph) # network analysis and visualization
library(knitr) # general-purpose tool for dynamic report generation
library(kableExtra) # table formatting
library(lemon) # functions for working w/ ggplot2 and knitr extensions
library(tibble) # modern dataframes
library(tidygraph)
library(doParallel)
library(networkD3)
library(ForceAtlas2)

source(paste(getwd(),"/helpers/all_helper.r",sep = ""), chdir = T)
```

## Nouns

Hills selected nouns from the Todler version of the MacArthur-Bates Communicative Developmental Inventory. This includes nouns which were aquired by 50% of children by 30 months. *This needs to be fixed to match Hills exactly*.

```{r warning=FALSE}
# We begin by importing data from wordbank. Age of aquisition (in months, it starts with 16, 17,..) is that at which 50% of children can produce the word. We also do naive triming at this point, this means we are ignoring homophone/polysemy (chiken (food), chiken (animals), etc,.. but we will have to be careful in our choices if we are preparing later for publication.

full_vocab <- make_vocab_dataframe(lang="English (American)",
                              lang_form = "WS",
                              lex_class = "nouns") %>%
  trim_all_unilemma() %>%
  trim_all_definition()
```

The initial vocabulary contains `r nrow(full_vocab)` (compared to Hills' 312).

## Features

Features taken from McRae et al. (2005), in which features were collected for 541 nouns from 725 adults, with 30 adults providing  14 features for each noun.

```{r warning=FALSE}
features <- load_features()

vocab <- full_vocab %>%
  filter(age <= 30) %>%
  filter(uni_lemma %in% features$uni_lemma) %>%
  distinct(uni_lemma, .keep_all = TRUE)
```

Only the words for which feature data are available are considered, an overlap of `r nrow(vocab)` in our data compared to Hills' 130.

## Build Networks

Using vocabulary obtained by 30 months and the same MacRae features as Hills, we construct networks from perceptual and conceptual features. We track the number of features that generate each edge.

```{r message=FALSE}
perceptual_features = c("sound", "taste", "smell", "tactile",
                           "visual-form_and_surface", "visual-motion", "visual-color")
conceptual_features = c("function")

full_network <- feature_network(vocab, features, shared_threshold = 1,
                                feature_types = c(perceptual_features,
                                                  conceptual_features)) %>%
                  set.graph.attribute("type", "both") %>%
                  set.graph.attribute("age", 30)

perceptual_network <- feature_network(vocab, features, shared_threshold = 1,
                                      feature_types = perceptual_features) %>%
                        set.graph.attribute("type", "perceptual") %>%
                        set.graph.attribute("age", 30)

conceptual_network <- feature_network(vocab, features, shared_threshold = 1,
                                      feature_types = conceptual_features) %>%
                        set.graph.attribute("type", "conceptual") %>%
                        set.graph.attribute("age", 30)
```

# Results

## The Full Network

### Network statistics and small-world analyses

```{r}
# testing dense layout
source(paste(getwd(),"/helpers/all_helper.r",sep = ""), chdir = T)

plot_network(full_network %E>% filter(shared >= 2), remove_isolated = TRUE, labels=TRUE, frame=TRUE)
```


The full network is shown in the following figure, for w = 1, 2, 3, and 4.

```{r out.width = '100%'}
full_networks = list()
for (w in 1:4) {
  full_networks[[w]] = full_network %E>%
    filter(shared >= w)
}

#par(mfcol=c(2, 2), mar=c(0.5,0.5,0.5,0.5))
for (network in full_networks) {
  plot_network(network, remove_isolated = FALSE, labels=TRUE, frame=TRUE)
}
```





## Basic Vocab and Feature Properties

## Basic Network Properties

Some basic properties of networks built from perceptual and conceptual features.
```{r, results='asis'}
max_w <- 4

network_properties <- function(networks) {
  return( tibble(
  name = map_chr(networks, ~ .x$name),
  type = map_chr(networks, ~ .x$type),
  age = map_dbl(networks, ~ .x$age) %>%
    as.integer(),
  w = map_dbl(networks, ~ .x$w) %>%
    as.integer(),
  vertices = map_int(networks, vcount),
  edges = map_dbl(networks, ecount) %>%
    as.integer(), # for some reason igraph ecount returns double
  avg_degree = map(networks, degree) %>%
    map_dbl(mean),
  avg_shortest_path = map_dbl(networks, mean_distance),
  diameter = map_dbl(networks, diameter) %>%
    as.integer(),
  clustering_coefficient = map_dbl(networks, transitivity),
  density = edges / (vertices * (vertices - 1) / 2),
  avg_shortest_path_random = 0, # either estimate or calculate values for random nets
  diameter_random = 0,
  clustering_coefficient_random = density,
  isolates = map_dbl(networks, function (g) sum(degree(g) == 0)),
  components = map_dbl(networks, count_components) %>%
    as.integer() - isolates))
}

full_networks <- list()
perceptual_networks <- list()
conceptual_networks <- list()
for (w in 1:max_w) {
  full_networks[[w]] <- full_network %>%
    activate(what = edges) %>%
    filter(shared >= w) %>%
    set.graph.attribute("w", w)

  perceptual_networks[[w]] <- perceptual_network %>%
    activate(what = edges) %>%
    filter(shared >= w) %>%
    set.graph.attribute("w", w)

  conceptual_networks[[w]] <- conceptual_network %>%
    activate(what = edges) %>%
    filter(shared >= w) %>%
    set.graph.attribute("w", w)
}

networks <- full_networks %>%
  append(perceptual_networks) %>%
  append(conceptual_networks)

our_network_properties <- network_properties(networks)

our_network_properties %>%
  select(type, w, vertices, edges, avg_degree, diameter, avg_shortest_path, clustering_coefficient) %>%
  kable(format="html",
        escape = FALSE,
        col.names = c("Type", "w", "V", "E", "Average degree", "Diameter", "Average length", "Clustering coefficient"),
        digits = 2,
        align = rep("l", 8)) %>%
  kable_styling(full_width = F) %>%
  collapse_rows(columns = 1:3, valign = "top")
```

We can compare these networks to those from Hills, noting that we have a different set of words/nodes but that the induced subgraph of those words shared between our analysis and that of Hills should be the same.
```{r}
hills_network_properties <- tibble( # table from Hills 2009
  type = c(rep("all", times=4), rep("perceptual", times=4), rep("conceptual", 4)),
  w = c(1:max_w, 1:max_w, 1:max_w),
  clustering_coefficient = c(0.55, 0.54, 0.58, 0.60, 0.54, 0.54, 0.62, 0.62, 0.88, 0.59, 0.38, 1.00),
  avg_shortest_path = c(1.72, 2.57, 4.96, 3.22, 1.76, 2.69, 5.02, 2.55, 3.08, 1.59, 5.02, 1.00),
  density = c(0.29, 0.10, 0.04, 0.02, 0.27, 0.08, 0.03, 0.01, 0.05, 0.01, 0.0, 0.0),
  components = c(1, 1, 4, 10, 1, 2, 8, 11, 7, 14, 7, 2),
  isolates = c(0, 6, 20, 47, 0, 10, 31, 69, 33, 81, 113, 126)
)

# convert contents to text
display_our_properties <- our_network_properties %>% mutate_all(funs(format(., digits=2, trim=TRUE)))
display_hills_properties <- hills_network_properties %>% mutate_all(funs(paste("(", ., ")", sep='')))

# combine text tables for display
display_properties <- bind_rows(display_our_properties %>% mutate(row = 1:n()),
                                display_hills_properties %>% mutate(row = 1:n())) %>%
  group_by(row) %>%
  summarise_if(is.character, funs(paste(., collapse=" "))) %>%
  arrange(row)

# display combined properties
select(hills_network_properties, type, w) %>%
  bind_cols(select(display_properties, clustering_coefficient, avg_shortest_path,
                   density, components, isolates)) %>%
  kable(format="html",
        escape = FALSE,
        col.names = c("Type", "w", "Clustering Coefficient", "Average length", "Density", "Components", "Isolates"),
        align = rep("l", 7)) %>%
  kable_styling(full_width = F) %>%
  collapse_rows(columns = 1:2, valign = "top")
```

# Clusters

## Visualize Networks
```{r out.width = '100%'}
networks <- perceptual_networks[2]
```

## Clique Percolation

Initial Clique Analysis
```{r out.width = '100%'}
trimmed_networks <- map(networks, function (g) delete.vertices(g, degree(g)==0))

# cl <- makeCluster(3)
# registerDoParallel(cl)
# getDoParWorkers()
## Plot with the new colors
for (net in networks) {
  for (k in 3:4) {
    clusters <- clique.community.opt(net,k)
    plot_network(net, clusters = clusters, labels=FALSE)
  }
}
# stopCluster(cl)
```

Dynamic Visualization
```{r}
conceptual_clusters <- membership(cluster_walktrap(conceptual_network))

# Convert to object suitable for networkD3
conceptual_d3 <- igraph_to_networkD3(conceptual_network, group = conceptual_clusters)

# Create force directed network plot
forceNetwork(Links = conceptual_d3$links, Nodes = conceptual_d3$nodes,
             Source = 'source', Target = 'target', NodeID = 'name',
             Group = 'group')
```

