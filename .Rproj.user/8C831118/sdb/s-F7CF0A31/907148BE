{
    "collab_server" : "",
    "contents" : "\nList of libraries\n```{r}\n  library(purrr)\n  library(readr)\n  library(ggplot2)\n  library(langcog)\n  library(boot)\n  library(dplyr)\n  library(tidyr)\n  library(wordbankr)\n  library(directlabels)\n  library(stringr)\n  library(lmtest)\n  library(rwebppl)\n  library(jsonlite)\n  library(nlme)\n  library(feather)\n  library(broom)\n  library(HDInterval)\n  library(BBmisc)\n  library(igraph)\n```\n\n\nImport helper functions\n\n\n```{r}\nsource(paste(getwd(),\"/helpers/all_helper.r\",sep = \"\"), chdir = T)\n```\n\n\nCreate pairs \n\n```{r}\n#Import data form wordbank in a format that will be useful for us (especially when we will do development in time).\n\n#The format: for each age (in months, it starts with 16, 17,..) list all words that have NOT yet been acquired  (acquisition is defined by the criterion that 50% of the children can produce the word). The \"defintion\" is the word, the \"unilemma\"\" is the translation in English (but since we are using only English at this point, both are the same). \"learned\" is 1 when the word is acquired at that month, and 0 when the word is not aquired at that month. Thus, words with learned=1 at month n, will disapear from month n+1\n\nwb_data <- make_aoa_dataframe(lang=\"English (American)\", lang_form = \"WS\", lex_class = \"nouns\")\n\n\n#extract the first age (it is 16 month in English)\nfirst_age<- wb_data$age[1]\n\n#Extract the list of all uni_lemmas (like Hills, we will start with the analysis of all words first)\nlemma_list<- wb_data %>%\n  trim_all_unilemma() %>% #We do naive triming at this point, this means we are ignoring homophone/polysemy (chiken (food), chiken (animals), etc,.. but we will have to be careful in our choices if we are preparing later for publication\n  filter(age==first_age) %>% #Since the fisrt month in our format is the month when all words are stil present \n  select(item, uni_lemma) \n    \n    # list of definitions (we don't need them at this point)\n    def_list<- wb_data %>%\n      trim_all_definition() %>% \n      filter(age==first_age) %>%\n      select(item, definition)\n    \n#Make list of pairs for associative data\n#The output: all pairs of words (first is named \"item\"\" and seoncd is named \"pair\"), link =0 (no link), =1 (there is a link)\nassoc_pairs<- make_assoc_pairs(lemma_list = lemma_list)\n\n#Make list of pairs for MacRae features\n#The output: same as above, but here instead of link, we have \"shared\" which specify the number of shared links \nfeature_pairs <- make_feature_pairs(lemma_list = lemma_list)\n```\n\n\n```\n```\n\nSome useful functions\n\n```{r}\n\n#Extract the words\nget_lang_item_data <- function(lang, lang_form = \"WS\", lex_class = \"nouns\") {\n\n  item_data <- get_item_data(language = lang, form = lang_form) %>%\n    select(num_item_id, definition, type, lexical_class, uni_lemma) %>%\n    filter(type == \"word\", lexical_class == lex_class) %>%\n    rename(item = num_item_id)\n  \n  #Initialize every item as NA (NOT yet learnt)\n  lang_item <- item_data %>%\n    select(item, definition, uni_lemma) %>%\n    mutate(age = NA)\n  \n  return(lang_item)\n}\n\n##Extract the children' id (named data_id)  and their age\nget_lang_admin_data <- function(lang, lang_form = \"WS\") {\n  #get the kids' data_id from every age\n  admin_data <- get_administration_data() %>%\n    filter(form == lang_form, !is.na(production), language == lang) %>%\n    select(data_id, age) %>%\n    arrange(age)\n  \n  return(admin_data)\n}\n\n##get the children's id and the along with word's id (here called item) and whether the child produces that word (value)\n##note that here we only select children who do produce the words\nget_lang_instr_data <- function(lang, lang_form = \"WS\") {\n  instr_data <- get_instrument_data(instrument_language = lang,\n                                    instrument_form = lang_form) %>%\n    filter(value == \"produces\") %>%\n    arrange(num_item_id) %>%\n    rename(item = num_item_id)\n  \n  return(instr_data)\n}\n\n\n# Number of kids in every age\nget_kids_by_age <- function(admin_data) {\n  #get number of kids by age\n  nkids_by_age <- admin_data %>%\n    group_by(age) %>%\n    summarise(n = n())\n  return(nkids_by_age)\n}\n\n## This fucntion takes output from all previous function and ??,\nget_lang_aoa <- function(item_data, admin_data, instr_data) {\n  nkids_by_age <- get_kids_by_age(admin_data)\n  ages<- nkids_by_age$age\n  \n  #Calculate the age of acqusition for each word (defined as the month when at least 50% of the kids produce it)\n  for (cur_age in ages) {\n    rem_item <- item_data %>% filter(is.na(age))\n    current_age_id <- admin_data %>% filter(age == cur_age)\n    current_instr <- instr_data %>% \n      filter(data_id %in% current_age_id$data_id)\n    for (w in rem_item$item) {\n      proportion <- sum(current_instr$item == w) / nkids_by_age$n[which(ages==cur_age)]\n      if (proportion >= 0.5) {\n        item_data$age[which(item_data$item == w)] = cur_age\n      }\n    }\n  }\n  word_aoa<- item_data %>% filter(!is.na(age))\n  return(word_aoa)\n}\n\n\n#check how many words are learnt each age\nget_nwords_by_age <- function(word_aoa) {\n  nwords_by_age <- word_aoa %>%\n    arrange(age) %>%\n    group_by(age) %>%\n    summarise(n = n())\n  \n  return(nwords_by_age)\n}\n\n######################################################################################################################\n#make a final dataframe\nmake_aoa_dataframe_helper <- function(word_aoa) {\n  ages<- get_nwords_by_age(word_aoa)$age\n  df <- data.frame()\n  for (i in ages) {\n    rem_words <- word_aoa %>% filter(age >= i)\n    rem_lemma <- c(rem_words$uni_lemma)\n    rem_def <- c(rem_words$definition)\n    rem_item<- c(rem_words$item)\n    corr_age <- rep(i, times = length(rem_lemma))\n    curr_df <- data.frame(corr_age, rem_item, rem_lemma, rem_def)\n    df <- rbind(df, curr_df)\n  }  \n  df <- df %>% rename(uni_lemma = rem_lemma, definition=rem_def, item=rem_item)%>%\n    left_join(word_aoa %>% select(item, age)) %>%\n    mutate(learned = as.numeric(age == corr_age)) %>%\n    select(corr_age, item, definition, uni_lemma,learned) %>%\n    rename(age = corr_age) %>%\n    arrange(age, item)\n  return(df)\n}\n\n\nitem_data <- get_lang_item_data(lang = 'English (American)')\n\nadmin_data <- get_lang_admin_data(lang = 'English (American)')\n\ninstr_data <- get_lang_instr_data(lang = 'English (American)')\n\nnkids_by_age <- get_kids_by_age(admin_data)\n\nword_aoa <- get_lang_aoa(item_data = item_data,\n                 admin_data = admin_data,\n                 instr_data = instr_data)\n\n#We might not need this right now since we start with all words (but we might need this if we decide to do lexical growth)\nfinal <- make_aoa_dataframe_helper(word_aoa)\n\n\n\n```\n```{r}\ntrim_all_unilemma<-function(unilemma_list){\n  unilemma_list<- unilemma_list %>%\n    mutate(uni_lemma=gsub(\" \\\\s*\\\\([^\\\\)]+\\\\)\",\"\", uni_lemma)) %>%\n    mutate(uni_lemma=gsub(\"[*].*$\",\"\", uni_lemma)) %>%\n    filter(!is.na(uni_lemma))\n  return(unilemma_list)\n}\n\n######################################################################################################################\ntrim_all_definition<-function(def_list){\n  def_list<- def_list %>%\n    mutate(definition= gsub(\" \\\\s*\\\\([^\\\\)]+\\\\)\",\"\", definition)) %>%\n    mutate(definition= gsub(\"[*].*$\",\"\", definition)) %>%\n    mutate(definition= gsub(\"\\\\/.*\", \"\", definition)) %>%\n    filter(definition!= \"babysitter's name\", \n           definition!= \"child's own name\", \n           definition!= \"pet's name\") %>%\n    mutate(definition= gsub(\"[[:punct:]]\", \"\", definition)) \n  \n  return(def_list)\n}\n```\n\n\n```{r}\n#list of lemmas of learnt words\nfirst_age<- final$age[1]\n\n    lemma_list<- final %>%\n      trim_all_unilemma() %>%\n      filter(age==first_age) %>%\n      select(item, uni_lemma) \n    \n    # list of definitions of learnt words\n    def_list<- final %>%\n      trim_all_definition() %>% \n      filter(age==first_age) %>%\n      select(item, definition)\n```\n\nAssociative parirs\n\n```{r}\nmake_assoc_pairs <- function(lemma_list) {\n  \n  cue_target<- read.csv(\"data/association_cue_target.csv\", as.is = T)\n  # filter until words in lemma_list remain\n  lemma_list<- lemma_list %>% filter((uni_lemma %in% cue_target$cue) | (uni_lemma %in% cue_target$target))\n  lemma<- lemma_list$uni_lemma\n  cue_target<- cue_target %>% \n    filter(cue %in% lemma, \n           target %in% lemma, \n           normed==\"YES\") %>% \n    select(cue, target) %>% \n    mutate(link=1)\n  \n  assoc_table<- expand.grid(cue= lemma, target= lemma) %>% \n    left_join(cue_target) %>% \n    mutate(link=if_else(is.na(link),0,link))\n  \n  #make a association network dataframe with item number\n  #rename stuffs so it could conform to the format  needs\n  #item corresponds to target ;  pair corresponds to cue\n  assoc_link <- assoc_table %>%\n    rename(pair.definition = cue) %>%\n    left_join(lemma_list, c(\"pair.definition\" = \"uni_lemma\")) %>%\n    rename(pair = item, item.definition = target) %>%\n    left_join(lemma_list, c(\"item.definition\" = \"uni_lemma\")) %>%\n    select(item, item.definition, pair, pair.definition, link) %>%\n    arrange(item, pair) %>%\n    filter(item!=pair)\n  \n  return(assoc_link)\n}\n\n```\n\nMacRae features\n\n```{r}\n\nmake_McRae_pairs <- function(lemma_list) {\n  #Get the McRae features\n  features <-\n    hi <- read_delim(\"data/MacRae.csv\", delim = \",\") %>%\n    select(Concept, Feature, WB_Label, BR_Label) %>%\n    rename(uni_lemma=Concept)\n  #Intersection of Wordbank with McRae concepts\n  #(Note that we work with unilemmas and not with definitions becuase we would like to use cross-linguistic data)\n  \n  #List of word types in WordBank\n  wb <- lemma_list\n  # List of wordbank with feature\n  \n  #Here I still should deal with words in parenthesis (homophony/polysemy), e.g., chiken (animal) vs. chiken (food), etc...\n  \n  item_feat <- wb %>%\n    left_join(features) %>%\n    rename(item.definition = uni_lemma,\n           item_feat = Feature) %>%\n    filter(!is.na(item_feat)) %>%\n    select(item, item.definition, item_feat)\n  \n  \n  item_feat_list <- (wb %>%\n                       filter(item %in% item_feat$item) %>%\n                       select(item))$item\n  \n  # List these words pair-wise and compate the number of shared feature for each pair\n  item_pair <- expand.grid(item = item_feat_list,\n                           pair = item_feat_list)\n  \n  pair_feat <- item_feat %>%\n    rename(pair = item,\n           pair_feat = item_feat,\n           pair.definition = item.definition)\n  \n  item_feat_pair <- left_join(item_feat, item_pair)\n  \n  item_pair_feat <- item_feat_pair %>%\n    left_join(pair_feat)\n  \n  item_pair_shared <- item_pair_feat %>%\n    group_by(item, item.definition, pair, pair.definition) %>%\n    summarise(shared = sum(pair_feat == item_feat)) %>%\n    filter(item!=pair)\n  \n  return(item_pair_shared)\n}\n```\n\n\n\n```{r}\nassoc_pairs<- make_assoc_pairs(lemma_list = lemma_list)\nfeature_pairs <- make_McRae_pairs(lemma_list = lemma_list)\n```\n\n",
    "created" : 1524756243938.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "2840218032",
    "id" : "907148BE",
    "lastKnownWriteTime" : 1524769474,
    "last_content_update" : 1524769474504,
    "path" : "~/Documents/Experiments/conceptNet/Main.Rmd",
    "project_path" : "Main.Rmd",
    "properties" : {
    },
    "relative_order" : 1,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_markdown"
}